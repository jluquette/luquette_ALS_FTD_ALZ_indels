# vim: syntax=python

# >6.0 is required for modules
from snakemake.utils import min_version
min_version("6.0")

import yaml
import pandas as pd

chrs = [ x for x in range(1, 23) ]   # Chromosomes to analyze (autosomes)
output_plot_and_table = [ 'svg', 'pdf', 'tsv' ]  # Common plot+table output

# Read in the input manifest
manifest = pd.read_csv('manifests/INPUT_MANIFEST', sep='\t',comment='#')
celltypes = set(manifest['celltype'])
qualtypes = set(manifest['qualtype'])
celltypes_to_compute = [ 'neuron', 'oligo' ]

# PTA neurons/oligos were randomly divided into two groups within each
# age class (infant, adolescent, adult, elderly) to provide some guidance
# on how many single cells might be needed to derive a robust signal.
celltypes_halves = [ 'neuron_half1', 'neuron_half2', 'oligo_half1', 'oligo_half2' ]
snv_qualtypes = [ 'A', 'AB' ]
indel_qualtypes = [ 'indel_A', 'indel_AB' ]
all_qualtypes = snv_qualtypes + indel_qualtypes

# Constant config variables for the enrichment pipeline
binsizes = [ '1000', '10000', '100000', '1000000' ]
qsizes = [ 3, 5, 10, 50 ]
qsizes_to_compute = [ 10, 50 ]


with open('metadata/scan2_objects.yaml') as yf:
    scan2_objects = yaml.load(yf, Loader=yaml.FullLoader)



# The output directory and signal files are the only parameters that should
# change between analyses.
enrichment_config = {
    #'output_dir': 'path/to/output',
    #'SIGNAL_MANIFEST': 'path/to/sig.csv',

    # These parameters should not change between analyses
    'qbed_from_bigwig_script': 'snakemake/scripts/make_qbed_from_bigwig.sh',
    'quantiles': qsizes,
    # must match binsizes
    'tiles': {
        '1000000': 'alignability/genome_tiles/genome_tiles_1000000binsize.bed',
        '100000':  'alignability/genome_tiles/genome_tiles_100000binsize.bed',
        '10000':   'alignability/genome_tiles/genome_tiles_10000binsize.bed',
        '1000':    'alignability/genome_tiles/genome_tiles_1000binsize.bed'
    },
    'masks': {
        '1000000': 'alignability/genome_tiles/genome_mask_1000000binsize.bed',
        '100000':  'alignability/genome_tiles/genome_mask_100000binsize.bed',
        '10000':   'alignability/genome_tiles/genome_mask_10000binsize.bed',
        '1000':    'alignability/genome_tiles/genome_mask_1000binsize.bed'
    },
}


# Trying to use constraints to prevent snakemake from stack overflowing
# when building the DAG.
wildcard_constraints:
    mutclass='|'.join(expand("{celltype}{sigclass}___{qualtype}",
        celltype=celltypes, sigclass=[ '', '_sbs1', '_sbs16', '_sbs32' ], qualtype=qualtypes)),
    chr='|'.join([ str(i) for i in range(1,23) ]),
    binsize='|'.join(binsizes),
    celltype='|'.join(celltypes),
    qualtype='|'.join(qualtypes),
    cosmic='cosmic_full|cosmic_reduced',
    panel_letter='a|b|c|d|e|f|g|h|i|j|k|l',
    tumor='[^\.]+',  # No longer need this -[^\.]'   # Tumor codes are formatted XXXX-YYYY 
    sig='sbs1|sbs16|sbs32',  # for "simplified" analysis of sbs1 and sbs16 enrichment using CG:C>T and ATN:T>C rather than signature fitting
    half='|_half1|_half2'
    #umap='atac|rna',



# Shortcuts to rebuild a single figure at a time
rule fig1:
    input:
        "fig1/panel_b_aging_rates_A.pdf",
        "fig1/panel_b_aging_rates_A_burdens.csv",
        "fig1/panel_b_aging_rates_A_model.csv",
        "fig1/panel_b_aging_rates_indel_A.pdf",
        "fig1/panel_b_aging_rates_indel_A_burdens.csv",
        "fig1/panel_b_aging_rates_indel_A_model.csv",
        "fig1/panel_c_genic_enrichment.pdf",
        "fig1/panel_c_genic_enrichment.csv",
        "fig1/panel_d_snpeff.pdf",
        "fig1/panel_d_snpeff.csv"

rule suppfig2:
    input:
        "suppfig2/panel_b_indelsize.pdf",
        "suppfig2/panel_b_indelsize.csv",
        "suppfig2/panel_c_mda_elderly.pdf",
        "suppfig2/panel_c_mda_elderly.csv",
        "suppfig2/panel_d_genes.pdf",
        "suppfig2/panel_d_genes.jpeg",
        "suppfig2/panel_d_genes.csv"

rule fig2:
    input:
        "fig2/panel_a.pdf",
        "fig2/panel_a.csv",
        expand("fig2/panel_b___{celltype}___A.{ext}",
            celltype=[ 'neuron', 'oligo' ], ext=[ 'pdf', 'csv' ]),
        "fig2/panel_c_A.pdf",
        "fig2/panel_c_A.csv",
        "fig2/panel_d.pdf",
        "fig2/panel_d.svg",
        "fig2/panel_d_supplement.pdf",
        "fig2/panel_d_supplement.svg",
        "fig2/panel_d_spectra.csv",
        "fig2/panel_d_exposures_barplot.pdf",
        "fig2/panel_d_exposures_barplot.csv",
        "fig2/panel_e_infant.pdf",
        "fig2/panel_e_infant.svg",
        "fig2/panel_e_spectra_infant.csv",
        "fig2/panel_e_exposures_infant.csv"

rule fig3:
    input:
        "fig3/panel_a_spectrum.pdf",
        "fig3/panel_a_spectrum.csv",
        expand("fig3/panel_b___{celltype}___indel_A.{ext}",
            celltype=[ 'neuron', 'oligo' ], ext=[ 'pdf', 'csv' ]),
        "fig3/panel_c_indel_A.pdf",
        "fig3/panel_c_indel_A.csv",

rule fig4:
    input:
        "fig4/panel_a_umap_plot.pdf",
        "fig4/panel_c_umap_plot.pdf",
        "fig4/panels_cdefg_enrichment_analyses.pdf",
        "fig4/panels_cdefg_enrichment_analyses_half1.pdf",
        "fig4/panels_cdefg_enrichment_analyses_half2.pdf",
        "fig4/panel_h_chromhmm.pdf",
        "fig4/panel_h_chromhmm.csv",
        "fig4/panel_i_nott_enhprom.pdf",
        "fig4/panel_i_nott_enhprom.csv",
        #"fig4/panel_e_supplement_3quantiles.pdf",
        #"fig4/panel_e_supplement_5quantiles.pdf",
        #"fig4/panel_e_supplement_10quantiles.pdf",
        #"fig4/panel_e_supplement_neuron_sbs16___A.10quantiles.pdf",
        #"fig4/panel_e_supplement_oligo_sbs1___A.10quantiles.pdf",
        #"fig4/panel_e_supplement_oligo_sbs32___A.10quantiles.pdf",
        #"fig4/suppl_nott_enhprom.pdf",
        #"fig4/suppl_nott_enhprom.csv",
        #"fig4/suppl_boca2_peaks.pdf",
        #"fig4/suppl_boca2_peaks.csv",
        #"fig4/suppl_dna_repair_hotspots.pdf",
        #"fig4/suppl_dna_repair_hotspots.csv",
        #"fig4/suppl_hic_tads.pdf",
        #"fig4/suppl_hic_tads.csv",
        #"fig4/rna_atac_foldchange.pdf",
        #"fig4/rna_atac_foldchange.csv",

rule suppfig3:
    input:
        "suppfig3/panel_a_gtex_expression_neuron___AB.pdf",
        "suppfig3/panel_a_gtex_expression_neuron___AB.csv",
        "suppfig3/panel_a_gtex_expression_oligo___AB.pdf",
        "suppfig3/panel_a_gtex_expression_oligo___AB.csv",
        "suppfig3/panel_a_gtex_expression_neuron___indel_AB.pdf",
        "suppfig3/panel_a_gtex_expression_neuron___indel_AB.csv",
        "suppfig3/panel_a_gtex_expression_oligo___indel_AB.pdf",
        "suppfig3/panel_a_gtex_expression_oligo___indel_AB.csv",
        "suppfig3/panel_b_repliseq___AB.pdf",
        "suppfig3/panel_b_repliseq___AB.csv",
        "suppfig3/panel_b_repliseq___indel_AB.pdf",
        "suppfig3/panel_b_repliseq___indel_AB.csv",
        "suppfig3/panel_c_chromhmm_tss.pdf",
        "suppfig3/panel_c_chromhmm_tss.csv",

rule fig5:
    input:
        "fig5/all_panels_enrichment_analyses.pdf"

rule fig6:
    input:
        "fig6/panel_a.pdf",
        "fig6/panel_a.csv",
        "fig6/panel_a_mdapta_supp.pdf",
        "fig6/panel_a_mdapta_supp.csv",
        "fig6/panel_b_barplot.pdf",
        "fig6/panel_b_heatmap.pdf",
        "fig6/panel_b.csv",
        "fig6/panel_c_barplot.pdf",
        "fig6/panel_c_heatmap.pdf",
        "fig6/panel_c.csv",
        "fig6/panel_d.pdf",
        "fig6/panel_d.csv",
        "fig6/panel_d_mdapta.pdf",
        "fig6/panel_d_mdapta.csv"

rule suppfig5:
    input:
        "suppfig5/cancer_gene_ors.pdf",
        "suppfig5/cancer_gene_ors_full.pdf",
        "suppfig5/cancer_gene_ors_mdapta.pdf",
        "suppfig5/cancer_gene_ors_mdapta_full.pdf"


rule misc:
    input:
        expand("fig1/indel_size_analysis/indel_size.{output}",
            output=[ 'pdf', 'svg']),
        expand("fig1/snpeff_analysis/snpeff_analysis.{output}",
            output=output_plot_and_table)


rule aging_rates:
    input:
        expand('aging_rates/{celltype}___mutburden___{qualtype}.csv',
            celltype=[ 'all' ] + celltypes_to_compute + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ]),  # only passA calls are used
        expand('aging_rates/all___mutburden_models___{qualtype}.csv',
            #celltype=celltypes_to_compute,
            qualtype=[ 'A', 'indel_A' ])


# For now this is just signature fitting. In both projects so far,
# de novo analysis produced only one signature.
rule mutsigs:
    input:
        expand("mutsigs/raw_spectra/{celltype}___raw_spectrum___{qualtype}.{output}",
            celltype=celltypes_to_compute + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        expand("mutsigs/cosmic_signature_inclusion/{celltype}___signature_scores___{qualtype}.csv",
            celltype=celltypes_to_compute + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ]),
        expand("mutsigs/cosmic_signature_inclusion/all___signature_selection___{qualtype}.csv",
            qualtype=[ 'A', 'indel_A' ]),
        expand("mutsigs/cosmic_aging/{celltype}___barplots___{qualtype}.{output}",
            celltype=celltypes_to_compute + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ],
            output=[ 'pdf', 'svg' ]),
        expand("mutsigs/cosmic_aging/all___cosmic_models_vs_age___{qualtype}.{output}",
            qualtype=[ 'A', 'indel_A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        # For MDA - excludes indels
        expand("mutsigs/cosmic_aging/all_mda___cosmic_models_vs_age___{qualtype}.{output}",
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        expand("mutsigs/raw_spectra/{celltype}___raw_spectrum___{qualtype}.{output}",
            celltype=[ 'oligo_mda', 'oligo_mda_2infants', 'oligo_mda_2elderly' ],
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        expand("mutsigs/cosmic_aging/{celltype}___barplots___{qualtype}.{output}",
            celltype=[ 'oligo_mda', 'oligo_mda_2infants', 'oligo_mda_2elderly', 'oligo_mdapta' ],
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg' ]),
        expand("mutsigs/cosmic_aging/{celltype}___cosmic_models_vs_age___{qualtype}.{output}",
            celltype=[ 'oligo_mda', 'oligo_mda_2infants', 'oligo_mda_2elderly' ],
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg', 'csv' ])

quantile_datasources = [ 'gtex_expression_mc' + x for x in [ '02', '08' ] ] + \
                [ 'scrnaseq_expression_mc' + x for x in [ '02', '08' ] ] + \
                [ 'nott', 'encode_replichip', 'repliseq', 'conservation', 
                  'scatacseq', 'cancer_snvdens', 'roadmap_histone_signal_brain', # ]
                  'scatacseq_foldchange', 'scrnaseq_expression_mc08_foldchange' ] # +

    # could do many min coverage values, but since we're using 1kb bins it doesn't matter much
                #[ 'scrnaseq_expression_mc' + x + "_foldchange" for x in [ '02', '08' ] ]


bed_region_datasources = [ 'boca2', 'dna_repair_hotspots', 'gencode', 'gencode_simplified',
                           'gtex_genes', 'nott', 'roadmap_chromhmm_brain', 'hic_tads' ]
                

# Enrichment analysis of total mutation burden
rule enrichment:
    input:
        # All quantile-based enrichment analyses of total mutation burden
        expand('enrichment/{datasource}/quantile/{celltype}___{qualtype}.{nquantiles}quantiles.{output}',
            celltype=celltypes_to_compute + celltypes_halves,
            qualtype=all_qualtypes,
            nquantiles=qsizes_to_compute,
            datasource=quantile_datasources,
            output=[ 'svg', 'pdf', 'csv' ]),
        # Enrichment analysis of specific regions
        expand('enrichment/{datasource}/bed_regions/{celltype}___{qualtype}.{output}',
            celltype=celltypes_to_compute + celltypes_halves,
            qualtype=all_qualtypes,
            datasource=bed_region_datasources,
            output=[ 'svg', 'pdf', 'csv' ]),
        # Just for MDA. Copy/paste because there are no indel classes for MDA (qualtypes=indel_A, etc).
        expand('enrichment/{datasource}/quantile/{celltype}___{qualtype}.{nquantiles}quantiles.{output}',
            celltype=[ 'oligo_mdapta', 'oligo_mda_2infants', 'oligo_mda_2elderly' ],
            qualtype=[ 'A', 'AB' ],
            nquantiles=qsizes_to_compute,
            datasource=quantile_datasources,
            output=[ 'svg', 'pdf', 'csv' ]),
        expand('enrichment/{datasource}/bed_regions/{celltype}___{qualtype}.{output}',
            celltype=[ 'oligo_mdapta', 'oligo_mda_2infants', 'oligo_mda_2elderly' ],
            qualtype=[ 'A', 'AB' ],
            datasource=bed_region_datasources,
            output=[ 'svg', 'pdf', 'csv' ])


rule spatial_enrichment:
    input:
        expand('enrichment/spatial_burden/{celltype}___{qualtype}___{binsize}binsize___{rolling}rolling.profile.csv',
            celltype=[ 'oligo', 'neuron', 'oligo_mdapta', 'oligo_mda_2infants', 'oligo_mda_2elderly' ],
            qualtype=[ 'A', 'AB' ],
            binsize=[ '100000', '1000000' ],
            rolling=[ '1', '10' ])


# Enrichment analysis of signature-specific mutation burden
# In theory would be done to all regions tested for total burden enrichment,
# but because of signature fitting inaccuracy, regions must be large.
rule signature_enrichment:
    input:
        expand('enrichment/{datasource}/quantile/{celltype}___{qualtype}.{nquantiles}quantiles_sigenrich.{output}',
            datasource=[ 'gtex_expression_mc' + x for x in [ '02', '04', '06', '08' ] ] +
                [ 'scrnaseq_expression_mc' + x for x in [ '02', '04', '06', '08' ] ] +
                [ 'nott', 'encode_replichip', 'repliseq', 'conservation', 'scatacseq', 'cancer_snvdens', 'roadmap_histone_signal_brain' ],
            celltype=celltypes_to_compute,
            qualtype=[ 'A', 'indel_A' ],
            nquantiles=[ 3, 5 ],
            output=[ 'svg', 'pdf', 'csv' ]),


include: "snakefile.data"
include: "snakefile.alignability"
include: "snakefile.aging_rates"
include: "snakefile.mutsigs"
include: "snakefile.fig1"
include: "snakefile.fig2"
include: "snakefile.fig3"
include: "snakefile.fig4"
include: "snakefile.fig5"
include: "snakefile.fig6"
include: "snakefile.suppfig2"
include: "snakefile.suppfig3"
include: "snakefile.supptables"
include: "snakefile.scatacseq"
include: "snakefile.gtex_enrichment"
include: "snakefile.scrnaseq_enrichment"
include: "snakefile.nott_enrichment"
include: "snakefile.boca_enrichment"
include: "snakefile.dnarepair_enrichment"
include: "snakefile.gene_region_enrichment"
include: "snakefile.spatial_enrichment"
include: "snakefile.cancer_genes"



########################################################################
# HiC TADs (A and B-compartments)
########################################################################
enrichment_hic_tads_config = dict(
    **{ 'output_dir': 'enrichment/hic_tads',
        'SIGNAL_MANIFEST': 'manifests/HIC_TADS.MANIFEST' },
    **enrichment_config
)

module enrichment_hic_tads:
    snakefile: "snakefile.bed_enrichment"
    config: enrichment_hic_tads_config

use rule * from enrichment_hic_tads as enrichment_hic_tads_*

# contains ~30 tracks at ~250k resolution
# needed ~30GB for neuron___A, so guessing maybe double for oligo_mdapta
# needed ~56B for oligo_mda_2elderly
# I have no idea why these memory usages are so high. indel analysis only
# requires ~2GB, so the size of the BED file is unlikely to be the culprit.
# for now, just brute force it
use rule enrichment_bed_analysis from enrichment_hic_tads as enrichment_hic_tads_enrichment_bed_analysis with:
    resources:
        mem=128000

########################################################################
# Roadmap epigenomics chromHMM  state models
########################################################################
enrichment_roadmap_chromhmm_config = dict(
    **{ 'output_dir': 'enrichment/roadmap_chromhmm_brain',
        'SIGNAL_MANIFEST': 'manifests/ROADMAP_CHROMHMM_BRAIN.MANIFEST' },
    **enrichment_config
)

module enrichment_roadmap_chromhmm:
    snakefile: "snakefile.bed_enrichment"
    config: enrichment_roadmap_chromhmm_config

use rule * from enrichment_roadmap_chromhmm as enrichment_roadmap_chromhmm_*

# Uses 200 bp tiles and has >200 tracks, so give it a generous amount of RAM
# N.B. failed with 32G after 1 hour of loading BED files
# Max usage was ~37G.
# -- The above is no longer applicable when using only the 13 brain samples.
# -- but leaving in here anyway in case we go back to the full catalog.
use rule enrichment_bed_analysis from enrichment_roadmap_chromhmm as enrichment_roadmap_chromhmm_enrichment_bed_analysis with:
    resources:
        mem=42000

use rule enrichment_bed_plot from enrichment_roadmap_chromhmm as enrichment_roadmap_chromhmm_enrichment_bed_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        xlab='eid',
        xgroup='quantile',
        ygroup='model',
        highlight='eid=E073'


########################################################################
# Roadmap epigenomics histones
########################################################################
enrichment_roadmap_histone_signal_config = dict(
    **{ 'output_dir': 'enrichment/roadmap_histone_signal_brain',
        'SIGNAL_MANIFEST': 'manifests/ROADMAP_HISTONE_BIGWIG_BRAIN.MANIFEST' },
    **enrichment_config
)

module enrichment_roadmap_histone_signal:
    snakefile: "snakefile.enrichment"
    config: enrichment_roadmap_histone_signal_config

use rule * from enrichment_roadmap_histone_signal as enrichment_roadmap_histone_signal_*

use rule sigenrichment_qbed_analysis from enrichment_roadmap_histone_signal as enrichment_roadmap_histone_signal_sigenrichment_qbed_analysis with:
    resources:
        mem=lambda wildcards: 96000 if wildcards.binsize == '1000' or wildcards.nquantiles == '50' else 30000

use rule enrichment_plot from enrichment_roadmap_histone_signal as enrichment_roadmap_histone_signal_enrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='mark'
    output:
        expand('enrichment/roadmap_histone_signal_brain/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/roadmap_histone_signal_brain/quantile/{mutclass}.{nquantiles}quantiles.log'


use rule sigenrichment_plot from enrichment_roadmap_histone_signal as enrichment_roadmap_histone_signal_sigenrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='mark'
    output:
        expand('enrichment/roadmap_histone_signal_brain/quantile/{{mutclass}}.{{nquantiles}}quantiles_sigenrich.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/roadmap_histone_signal_brain/quantile/{mutclass}.{nquantiles}quantiles_sigenrich.log'


########################################################################
# ENCODE replication timing measured by Repli-chip
########################################################################
enrichment_encode_replichip_config = dict(
    **{ 'output_dir': 'enrichment/encode_replichip',
        'SIGNAL_MANIFEST': 'manifests/ENCODE_REPLICHIP.MANIFEST' },
    **enrichment_config
)

module enrichment_encode_replichip:
    snakefile: "snakefile.enrichment"
    config: enrichment_encode_replichip_config

use rule * from enrichment_encode_replichip as enrichment_encode_replichip_*

use rule sigenrichment_qbed_analysis from enrichment_encode_replichip as enrichment_encode_replichip_sigenrichment_qbed_analysis with:
    resources:
        mem=lambda wildcards: 70000 if wildcards.binsize == '1000' or wildcards.nquantiles == '50' else 30000

use rule enrichment_plot from enrichment_encode_replichip as enrichment_encode_replichip_enrichment_plot with:
    params:
        ignore='BINSIZE=1000',
        group='datasource'
    output:
        expand('enrichment/encode_replichip/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/encode_replichip/quantile/{mutclass}.{nquantiles}quantiles.log'

use rule sigenrichment_plot from enrichment_encode_replichip as enrichment_encode_replichip_sigenrichment_plot with:
    params:
        ignore='BINSIZE=1000',
        group='datasource'
    output:
        expand('enrichment/encode_replichip/quantile/{{mutclass}}.{{nquantiles}}quantiles_sigenrich.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/encode_replichip/quantile/{mutclass}.{nquantiles}quantiles_sigenrich.log'


########################################################################
# Replication timing measured by Repliseq
########################################################################
enrichment_repliseq_config = dict(
    **{ 'output_dir': 'enrichment/repliseq',
        'SIGNAL_MANIFEST': 'manifests/REPLISEQ.MANIFEST' },
    **enrichment_config
)

module enrichment_repliseq:
    snakefile: "snakefile.enrichment"
    config: enrichment_repliseq_config

use rule * from enrichment_repliseq as enrichment_repliseq_*

use rule sigenrichment_qbed_analysis from enrichment_repliseq as enrichment_repliseq_sigenrichment_qbed_analysis with:
    resources:
        mem=lambda wildcards: 70000 if wildcards.binsize == '1000' or wildcards.nquantiles == '50' else 30000

use rule enrichment_plot from enrichment_repliseq as enrichment_repliseq_enrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='datasource'
    output:
        expand('enrichment/repliseq/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/repliseq/quantile/{mutclass}.{nquantiles}quantiles.log'

use rule sigenrichment_plot from enrichment_repliseq as enrichment_repliseq_sigenrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='datasource'
    output:
        expand('enrichment/repliseq/quantile/{{mutclass}}.{{nquantiles}}quantiles_sigenrich.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/repliseq/quantile/{mutclass}.{nquantiles}quantiles_sigenrich.log'


########################################################################
# Conservation tracks from UCSC
########################################################################
enrichment_conservation_config = dict(
    **{ 'output_dir': 'enrichment/conservation',
        'SIGNAL_MANIFEST': 'manifests/CONSERVATION.MANIFEST' },
    **enrichment_config
)

module enrichment_conservation:
    snakefile: "snakefile.enrichment"
    config: enrichment_conservation_config

use rule * from enrichment_conservation as enrichment_conservation_*

# Conservation tracks have bp resolution over the entire genome. This
# causes bigWigAverageOverBed to consume unbelievably large amounts of
# memory for large windows like 1MB.
use rule make_qbed_from_bigwig from enrichment_conservation as enrichment_conservation_make_qbed_from_bigwig with:
    resources:
        mem=65000

use rule enrichment_plot from enrichment_conservation as enrichment_conservation_enrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='track'
    output:
        expand('enrichment/conservation/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/conservation/quantile/{mutclass}.{nquantiles}quantiles.log'

use rule sigenrichment_plot from enrichment_conservation as enrichment_conservation_sigenrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='track'
    output:
        expand('enrichment/conservation/quantile/{{mutclass}}.{{nquantiles}}quantiles_sigenrich.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/conservation/quantile/{mutclass}.{nquantiles}quantiles_sigenrich.log'


########################################################################
# Our scATAC-seq data
########################################################################
enrichment_scatacseq_config = dict(
    **{ 'output_dir': 'enrichment/scatacseq',
        'SIGNAL_MANIFEST': 'manifests/SCATACSEQ.MANIFEST' },
    **enrichment_config
)

module enrichment_scatacseq:
    snakefile: "snakefile.enrichment"
    config: enrichment_scatacseq_config

use rule * from enrichment_scatacseq  as enrichment_scatacseq_*

use rule make_qbed_from_bigwig from enrichment_scatacseq as enrichment_scatacseq_make_qbed_from_bigwig with:
    resources:
        mem=15000

use rule enrichment_plot from enrichment_scatacseq as enrichment_scatacseq_enrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='celltype',
    output:
        expand('enrichment/scatacseq/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/scatacseq/quantile/{mutclass}.{nquantiles}quantiles.log'

use rule sigenrichment_plot from enrichment_scatacseq as enrichment_scatacseq_sigenrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='celltype',
    output:
        expand('enrichment/scatacseq/quantile/{{mutclass}}.{{nquantiles}}quantiles_sigenrich.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/scatacseq/quantile/{mutclass}.{nquantiles}quantiles_sigenrich.log'


########################################################################
# Our scATAC-seq data but using foldchange signals
#
# This differs from typical qbed analysis because there is no base
# bigwig signal files from which the qbeds are constructed. Instead,
# qbeds are created from the non-foldchange scATAC-seq qbeds.
########################################################################
enrichment_scatacseq_foldchange_config = dict(
    **{ 'output_dir': 'enrichment/scatacseq_foldchange',
        # This manifest is a dummy containing only metadata, not files
        'SIGNAL_MANIFEST': 'manifests/SCATACSEQ_FOLDCHANGE.MANIFEST' },
    **enrichment_config
)

module enrichment_scatacseq_foldchange:
    snakefile: "snakefile.enrichment"
    config: enrichment_scatacseq_foldchange_config

# Only qbed analysis is relevant
use rule enrichment_qbed_analysis from enrichment_scatacseq_foldchange as enrichment_scatacseq_foldchange_enrichment_qbed_analysis

use rule enrichment_table from enrichment_scatacseq_foldchange as enrichment_scatacseq_foldchange_enrichment_table

use rule enrichment_plot from enrichment_scatacseq_foldchange as enrichment_scatacseq_foldchange_enrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='celltype',
    output:
        expand('enrichment/scatacseq_foldchange/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/scatacseq_foldchange/quantile/{mutclass}.{nquantiles}quantiles.log'


########################################################################
# Cancer SNV density
########################################################################
enrichment_cancer_config = dict(
    **{ 'output_dir': 'enrichment/cancer_snvdens',
        'SIGNAL_MANIFEST': 'manifests/CANCER_SNVDENS.MANIFEST' },
    **enrichment_config
)

module enrichment_cancer:
    snakefile: "snakefile.enrichment"
    config: enrichment_cancer_config

use rule * from enrichment_cancer as enrichment_cancer_*

use rule enrichment_plot from enrichment_cancer as enrichment_cancer_enrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='signal_type'
    output:
        expand('enrichment/cancer_snvdens/quantile/{{mutclass}}.{{nquantiles}}quantiles.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/cancer_snvdens/quantile/{mutclass}.{nquantiles}quantiles.log'

use rule sigenrichment_plot from enrichment_cancer as enrichment_cancer_sigenrichment_plot with:
    params:
        ignore='enrichment_grid_R_ignore_none',
        group='signal_type'
    output:
        expand('enrichment/cancer_snvdens/quantile/{{mutclass}}.{{nquantiles}}quantiles_sigenrich.{output}',
            output=[ 'svg', 'pdf', 'csv' ])
    log:
        'enrichment/cancer_snvdens/quantile/{mutclass}.{nquantiles}quantiles_sigenrich.log'


# This must be defined below all other rules to use the
# rules.XXX.output directive.
rule all:
    input:
        "supptables/SuppTable1.csv",
        "supptables/SuppTable2.csv",
        rules.fig1.input,
        rules.fig2.input,
        rules.fig3.input,
        rules.fig4.input,
        rules.fig5.input,
        rules.fig6.input,
        rules.suppfig2.input,
        rules.suppfig3.input,
        rules.suppfig5.input,
    default_target: True


rule temp_all:
    input:
        rules.all.input,
        rules.enrichment.input,
        rules.spatial_enrichment.input
