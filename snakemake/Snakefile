# vim: syntax=python

# >6.0 is required for modules
from snakemake.utils import min_version
min_version("6.0")

import yaml
import pandas as pd

# Important note on the `config' dictionary: consolidate all global variables so
# they can be robustly passed to module calls.
config['metadata'] = pd.read_csv('metadata/sample_metadata.csv')
meta = config['metadata']  # Just for convenience within this Snakefile

with open('metadata/bams.yaml') as yf:
    bams = yaml.load(yf, Loader=yaml.FullLoader)
config['bams'] = bams

# `bams` is a dict mapping donor ID -> list(single cell bams, bulk bams, other bams), where
# each of the elements in the above list are also dicts mapping sample ID -> bam path.
# For convenience, flatten `bams` into just a list of file paths with no related metadata.
config['all_samples'] = sum([ list(bams[k][bt].keys()) for k in bams.keys() for bt in bams[k].keys()  ], [])

# Just single cell samples
config['all_single_cells'] = sum([ list(bams[k]['single_cell'].keys()) for k in bams.keys() ], [])

# Same as above, but instead of a flat list of sample names, flat list of BAM paths
config['all_bams'] = sum([ list(bams[k][bt].values()) for k in bams.keys() for bt in bams[k].keys()  ], [])

config['all_donors'] = list(bams.keys())

# Read in the input manifest
manifest = pd.read_csv('manifests/INPUT_MANIFEST', sep='\t',comment='#')
celltypes = set(manifest['celltype'])
qualtypes = set(manifest['qualtype'])
celltypes_to_compute = [ 'neuron', 'oligo' ]

# Coarse high-level groups that are constantly reused.
generic_groups = [ 'pta_neuron', 'pta_oligo', 'mda_sox10', 'mda_gfap' ]

# Convenience function to recognize a few constantly used grouping criteria. Expect
# more to be added. Should probably recognize everything listed in `generic_groups`.
def group_from_meta(group):
    if group == 'pta_neuron':
        subset = meta[(meta['amp'] == 'PTA') & (meta['type'] == 'neuron')]
    elif group == 'pta_oligo':
        subset = meta[(meta['amp'] == 'PTA') & (meta['type'] == 'oligo')]
    elif group == 'mda_sox10':
        subset = meta[(meta['amp'] == 'MDA') & (meta['selection'] == 'SOX10')]
    elif group == 'mda_gfap':
        subset = meta[(meta['amp'] == 'MDA') & (meta['selection'] == 'GFAP')]
    else:
        raise RuntimeError('unrecognized group "' + group + '"')

    return(subset)

# Run mutation signature-based rescue on cells grouped as follows:
#    1. All PTA-amplified neurons (nearly identical to Luquette et al 2022, except more neurons now).
#    2. All PTA-amplified SOX10-sorted oligodendrocytes
#    3. All MDA-amplified SOX10-sorted oligodendrocytes
#    4. All MDA-amplified GFAP-sorted oligodendrocytes.
# Note SCAN2 signature rescue is NOT DESIGNED for MDA amplified single cells.  After
# doing steps (3) and (4) above, the rescued calls are ignored.  They are run through
# the rescue pipeline just for the sake of uniform outputs.
scan2_rescue_groups = [ 'pta_neuron', 'pta_oligo', 'mda_sox10', 'mda_gfap' ]

def rescue_group_to_scan2_objects(rescue_group):
    subset = group_from_meta(rescue_group)
    return(dict(zip(
            list('scan2/' + subset['donor'] + '/scan2/sensitivity/' + subset['sample'] + '/scan2_object.rda'),
            list(subset['sample'])
        )))

config['scan2_rescue_groups'] = dict((g, rescue_group_to_scan2_objects(g)) for g in scan2_rescue_groups)
config['scan2_rescue_groups_reverse'] = \
    dict((sample, g) for g in scan2_rescue_groups for sample in rescue_group_to_scan2_objects(g).values())


def aging_group_to_scan2_objects(aging_group):
    subset = group_from_meta(aging_group)
    return(list('scan2/tiny_objects/' + subset['sample'] + '.rda'))

config['aging_groups'] = dict((g, aging_group_to_scan2_objects(g)) for g in generic_groups)

# No MDA here. That requires signature B correction
config['aging_groups_to_model'] = [ 'pta_neuron', 'pta_oligo' ]


mda_celltypes = [ 'mda_gfap', 'mda_sox10' ]

mda_celltypes_by_age = [ 'mda_gfap_elderly', 'mda_sox10_elderly', 'mda_gfap_infant', 'mda_sox10_infant' ]

# PTA neurons/oligos were randomly divided into two groups within each
# age class (infant, adolescent, adult, elderly) to provide some guidance
# on how many single cells might be needed to derive a robust signal.
#celltypes_halves = [ 'neuron_half1', 'neuron_half2', 'oligo_half1', 'oligo_half2' ]
snv_qualtypes = [ 'A', 'AB' ]
indel_qualtypes = [ 'indel_A', 'indel_AB' ]
all_qualtypes = snv_qualtypes + indel_qualtypes

# Constant config variables for the enrichment pipeline
binsizes = [ '1000' ] #, '10000', '100000', '1000000' ]
qsizes = [ 3, 5, 10, 50 ]
qsizes_to_compute = [ 10, 50 ]

# List of Ns to perform NMF on
config['nmf_sig_ns'] = [ 1, 2, 3, 4, 5, 6, 7, 8 ]



# The output directory and signal files are the only parameters that should
# change between analyses.
config['enrichment_config'] = {
    # These parameters should not change between analyses
    'qbed_from_bigwig_script': 'snakemake/scripts/make_qbed_from_bigwig.sh',
    'quantiles': qsizes,
    # must match binsizes.
    # UPDATE 5/2/23: removing larger bin sizes that were not used. As noted,
    # certain pipeline elements (like enrichment) use config['tiles'].keys()
    # to find all bin sizes.
    'tiles': {
        #'1000000': 'alignability/genome_tiles/genome_tiles_1000000binsize.bed',
        #'100000':  'alignability/genome_tiles/genome_tiles_100000binsize.bed',
        #'10000':   'alignability/genome_tiles/genome_tiles_10000binsize.bed',
        '1000':    'alignability/genome_tiles/genome_tiles_1000binsize.bed'
    },
    'masks': {
        #'1000000': 'alignability/genome_tiles/genome_mask_1000000binsize.bed',
        #'100000':  'alignability/genome_tiles/genome_mask_100000binsize.bed',
        #'10000':   'alignability/genome_tiles/genome_mask_10000binsize.bed',
        '1000':    'alignability/genome_tiles/genome_mask_1000binsize.bed'
    },
}


# Trying to use constraints to prevent snakemake from stack overflowing
# when building the DAG.
wildcard_constraints:
    mutclass='|'.join(expand("{celltype}{sigclass}___{qualtype}",
        celltype=celltypes, sigclass=[ '', '_sbs1', '_sbs16', '_sbs32' ], qualtype=qualtypes)),
    chr='|'.join([ str(i) for i in range(1,23) ]),
    binsize='|'.join(binsizes),
    celltype='|'.join(generic_groups), #celltypes),
    qualtype='|'.join(qualtypes),
    cosmic='cosmic_full|cosmic_reduced',
    panel_letter='a|b|c|d|e|f|g|h|i|j|k|l',
    tumor='[^\.]+',  # No longer need this -[^\.]'   # Tumor codes are formatted XXXX-YYYY 
    sig='sbs1|sbs16|sbs32',  # for "simplified" analysis of sbs1 and sbs16 enrichment using CG:C>T and ATN:T>C rather than signature fitting
    half='|_half1|_half2',
    mdatype='mda_all|mda_gfap|mda_sox10',
    nmf_spectype='ID|SBS',
    nmf_runtype='pta|mda|all',
    rescue_group='|'.join(scan2_rescue_groups),
    #umap='atac|rna',


rule scan2_panel_setup:
    input:
        "scan2/panel/makepanel/scan.yaml"

rule scan2_panel_run:
    input:
        "scan2/panel/makepanel/panel/panel.tab.gz",
        "scan2/panel/makepanel/makepanel_collected_benchmarks.txt"

rule scan2_setup:
    input:
        expand("scan2/{donor}/scan2/scan.yaml", donor=bams.keys())

def scan2_unpack_donors_and_samples(bams):
    ret = []
    for donor in bams.keys():
        ret = ret + expand("scan2/{donor}/scan2/sensitivity/{sample}/scan2_object.rda",
            donor=donor, sample=bams[donor]['single_cell'])
    return(ret)

rule scan2_call:
    input:
        scan2_unpack_donors_and_samples(bams)

rule scan2_rescue:
    input:
        expand('scan2/rescue_{rescue_group}/rescued_muts.txt',
            rescue_group=scan2_rescue_groups),
        expand('scan2/rescue_{rescue_group}/sig_homogeneity_tests.txt',
            rescue_group=scan2_rescue_groups)

rule scan2_digest:
    input:
        expand('scan2/{rescue_group}_mutations.{filter_status}.txt',
            rescue_group=scan2_rescue_groups,
            filter_status=[ 'FILTERED', 'UNFILTERED' ])

rule scan2_permtool:
    input:
        expand('scan2/permtool/{rescue_group}/perms_{muttype}_{passtype}.rda',
            rescue_group=scan2_rescue_groups,
            muttype=[ 'snv', 'indel' ],
            passtype=[ 'pass', 'rescue' ])

rule scan2_objects:
    input:
        expand('scan2/{size}_objects/{sample}.rda',
            size=[ 'full', 'tiny' ], sample=config['all_single_cells'])

rule chrx:
    input:
        expand("chrX/{donor}/mmq60.tab.{ext}",
            donor=bams.keys(), ext=[ 'gz', 'gz.tbi' ])

rule nmf:
    input:
        expand('nmf/{nmf_runtype}/sigprofiler/{nmf_spectype}/signatures_{n}.pdf',
            nmf_runtype=[ 'pta', 'mda', 'all' ], nmf_spectype=[ 'SBS', 'ID' ], n=config['nmf_sig_ns']),
        expand('nmf/{nmf_runtype}/sigprofiler/{nmf_spectype}/selection_criteria.pdf',
            nmf_runtype=[ 'pta', 'mda', 'all' ], nmf_spectype=[ 'SBS', 'ID' ])

rule mapd:
    input:
        expand("mapd/{sample}.mapd.txt", sample=config['all_samples'])


# Same as above for SCAN2 output
def ginkgo_unpack_donors_and_samples(bams):
    ret = []
    for donor in bams.keys():
        ret = ret + expand("ginkgo/{donor}/{sample}_{plottype}.jpeg",
                donor=donor,
                sample=list(bams[donor]['single_cell'].keys()) + list(bams[donor]['bulk'].keys()),
                plottype=[ 'CN', 'GC', 'SoS', 'counts', 'dist', 'hist', 'lorenz' ])
    return(ret)

rule ginkgo:
    input:
        # These are all plots
        ginkgo_unpack_donors_and_samples(bams),
        # These are the tables used to construct plots in case raw data is useful
        data=expand('ginkgo/{donor}/{table}',
            donor=bams.keys(),
            table=[ 'data', 'CNV1', 'CNV2', 'SegBreaks', 'SegCopy', 'SegFixed', 'SegNorm', 'SegStats'])


rule aging_rates:
    input:
        expand('aging_rates/{celltype}___mutburden___{qualtype}.csv',
            celltype=[ 'all' ] + config['aging_groups_to_model'], # + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ]),  # only passA calls are used
        expand('aging_rates/all___mutburden_models___{qualtype}.csv',
            qualtype=[ 'A', 'indel_A' ])


# For now this is just signature fitting. In both projects so far,
# de novo analysis produced only one signature.
rule mutsigs:
    input:
        expand("mutsigs/raw_spectra/{celltype}___raw_spectrum___{qualtype}.{output}",
            celltype=celltypes_to_compute, # + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        expand("mutsigs/cosmic_signature_inclusion/{celltype}___signature_scores___{qualtype}.csv",
            celltype=celltypes_to_compute, # + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ]),
        expand("mutsigs/cosmic_signature_inclusion/all___signature_selection___{qualtype}.csv",
            qualtype=[ 'A', 'indel_A' ]),
        expand("mutsigs/cosmic_aging/{celltype}___barplots___{qualtype}.{output}",
            celltype=celltypes_to_compute, # + celltypes_halves,
            qualtype=[ 'A', 'indel_A' ],
            output=[ 'pdf', 'svg' ]),
        expand("mutsigs/cosmic_aging/all___cosmic_models_vs_age___{qualtype}.{output}",
            qualtype=[ 'A', 'indel_A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        # For MDA - excludes indels
        expand("mutsigs/cosmic_aging/all_mda___cosmic_models_vs_age___{qualtype}.{output}",
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        expand("mutsigs/raw_spectra/{mdatype}___raw_spectrum___{qualtype}.{output}",
            mdatype=mda_celltypes_by_age,  # WANT by_age
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg', 'csv' ]),
        expand("mutsigs/cosmic_aging/{mdatype}___barplots___{qualtype}.{output}",
            mdatype=mda_celltypes, #_by_age,
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg' ]),
        expand("mutsigs/cosmic_aging/{mdatype}___cosmic_models_vs_age___{qualtype}.{output}",
            mdatype=mda_celltypes, #_by_age,
            qualtype=[ 'A' ],
            output=[ 'pdf', 'svg', 'csv' ])

quantile_datasources = [ 'gtex_expression_mc' + x for x in [ '02', '08' ] ] + \
                [ 'scrnaseq_expression_mc' + x for x in [ '02', '08' ] ] + \
                [ 'nott', 'encode_replichip', 'repliseq', 'conservation', 
                  'scatacseq', 'cancer_snvdens', 'roadmap_histone_signal_brain', # ]
                  'scatacseq_foldchange', 'scrnaseq_expression_mc08_foldchange' ] # +

    # could do many min coverage values, but since we're using 1kb bins it doesn't matter much
                #[ 'scrnaseq_expression_mc' + x + "_foldchange" for x in [ '02', '08' ] ]


bed_region_datasources = [ 'boca2', 'dna_repair_hotspots', 'gencode', 'gencode_simplified',
                           'gtex_genes', 'nott', 'roadmap_chromhmm_brain', 'hic_tads' ]
                

# Enrichment analysis of total mutation burden
rule enrichment:
    input:
        # All quantile-based enrichment analyses of total mutation burden
        expand('enrichment/{datasource}/quantile/{celltype}___{qualtype}.{nquantiles}quantiles.{output}',
            celltype=celltypes_to_compute, # + celltypes_halves,
            qualtype=all_qualtypes,
            nquantiles=qsizes_to_compute,
            datasource=quantile_datasources,
            output=[ 'svg', 'pdf', 'csv' ]),
        # Enrichment analysis of specific regions
        expand('enrichment/{datasource}/bed_regions/{celltype}___{qualtype}.{output}',
            celltype=celltypes_to_compute, # + celltypes_halves,
            qualtype=all_qualtypes,
            datasource=bed_region_datasources,
            output=[ 'svg', 'pdf', 'csv' ]),
        # Just for MDA. Copy/paste because there are no indel classes for MDA (qualtypes=indel_A, etc).
        # UPDATE 5/2/23: also removing pass=AB
        expand('enrichment/{datasource}/quantile/{celltype}___{qualtype}.{nquantiles}quantiles.{output}',
            celltype=[ 'oligo_mdapta', 'oligo_mda_2infants', 'oligo_mda_2elderly' ] + mda_celltypes_by_age,
            qualtype=[ 'A' ],
            nquantiles=qsizes_to_compute,
            datasource=quantile_datasources,
            output=[ 'svg', 'pdf', 'csv' ]),
        expand('enrichment/{datasource}/bed_regions/{celltype}___{qualtype}.{output}',
            celltype=[ 'oligo_mdapta', 'oligo_mda_2infants', 'oligo_mda_2elderly' ] + mda_celltypes_by_age,
            qualtype=[ 'A' ],
            datasource=bed_region_datasources,
            output=[ 'svg', 'pdf', 'csv' ])


rule spatial_enrichment:
    input:
        expand('enrichment/spatial_burden/{celltype}___{qualtype}___{binsize}binsize___{rolling}rolling.profile.csv',
            celltype=[ 'oligo', 'neuron', 'oligo_mdapta', 'oligo_mda_2infants', 'oligo_mda_2elderly' ],
            qualtype=[ 'A', 'AB' ],
            binsize=[ '100000', '1000000' ],
            rolling=[ '1', '10' ])


# Enrichment analysis of signature-specific mutation burden
# In theory would be done to all regions tested for total burden enrichment,
# but because of signature fitting inaccuracy, regions must be large.
rule signature_enrichment:
    input:
        expand('enrichment/{datasource}/quantile/{celltype}___{qualtype}.{nquantiles}quantiles_sigenrich.{output}',
            datasource=[ 'gtex_expression_mc' + x for x in [ '02', '04', '06', '08' ] ] +
                [ 'scrnaseq_expression_mc' + x for x in [ '02', '04', '06', '08' ] ] +
                [ 'nott', 'encode_replichip', 'repliseq', 'conservation', 'scatacseq', 'cancer_snvdens', 'roadmap_histone_signal_brain' ],
            celltype=celltypes_to_compute,
            qualtype=[ 'A', 'indel_A' ],
            nquantiles=[ 3, 5 ],
            output=[ 'svg', 'pdf', 'csv' ]),


include: "snakefile.data"
include: "snakefile.scan2"
include: "snakefile.scan2_per_donor"
include: "snakefile.sentieon_for_chrX"
include: "snakefile.nmf"
include: "snakefile.mapd"
include: "snakefile.ginkgo"
include: "snakefile.ginkgo_per_donor"
include: "snakefile.aging_rates"
#include: "snakefile.alignability"
#include: "snakefile.mutsigs"
#include: "snakefile.fig1"
#include: "snakefile.fig2"
#include: "snakefile.fig3"
#include: "snakefile.fig4"
#include: "snakefile.fig5"
#include: "snakefile.fig6"
#include: "snakefile.suppfig2"
#include: "snakefile.suppfig3"
#include: "snakefile.supptables"
#include: "snakefile.scatacseq"
#include: "snakefile.gtex_enrichment"
#include: "snakefile.scrnaseq_enrichment"
#include: "snakefile.nott_enrichment"
#include: "snakefile.boca_enrichment"
#include: "snakefile.dnarepair_enrichment"
#include: "snakefile.gene_region_enrichment"
#include: "snakefile.spatial_enrichment"
#include: "snakefile.cancer_genes"
#include: "snakefile.other_enrichment"

'''
# Shortcuts to rebuild a single figure at a time
rule fig1:
    input:
        "fig1/panel_b_aging_rates_A.pdf",
        "fig1/panel_b_aging_rates_A_burdens.csv",
        "fig1/panel_b_aging_rates_A_model.csv",
        "fig1/panel_b_aging_rates_indel_A.pdf",
        "fig1/panel_b_aging_rates_indel_A_burdens.csv",
        "fig1/panel_b_aging_rates_indel_A_model.csv",
        "fig1/panel_c_genic_enrichment.pdf",
        "fig1/panel_c_genic_enrichment.csv",
        "fig1/panel_d_snpeff.pdf",
        "fig1/panel_d_snpeff.csv"

rule suppfig2:
    input:
        "suppfig2/panel_b_indelsize.pdf",
        "suppfig2/panel_b_indelsize.csv",
        expand('suppfig2/panel_c_{mdatype}_{ageclass}.{ext}',
            mdatype=[ 'mda_gfap', 'mda_sox10' ],
            ageclass=[ 'elderly', 'infant' ],
            ext=[ 'pdf', 'csv' ]),
        "suppfig2/panel_d_genes.pdf",
        "suppfig2/panel_d_genes.jpeg",
        "suppfig2/panel_d_genes.csv"

rule fig2:
    input:
        "fig2/panel_a.pdf",
        "fig2/panel_a.csv",
        expand("fig2/panel_b___{celltype}___A.{ext}",
            celltype=[ 'neuron', 'oligo' ], ext=[ 'pdf', 'csv' ]),
        "fig2/panel_c_A.pdf",
        "fig2/panel_c_A.csv",
        "fig2/panel_d.pdf",
        "fig2/panel_d.svg",
        "fig2/panel_d_supplement.pdf",
        "fig2/panel_d_supplement.svg",
        "fig2/panel_d_spectra.csv",
        "fig2/panel_d_exposures_barplot.pdf",
        "fig2/panel_d_exposures_barplot.csv",
        "fig2/panel_e_infant.pdf",
        "fig2/panel_e_infant.svg",
        "fig2/panel_e_spectra_infant.csv",
        "fig2/panel_e_exposures_infant.csv"

rule fig3:
    input:
        "fig3/panel_a_spectrum.pdf",
        "fig3/panel_a_spectrum.csv",
        expand("fig3/panel_b___{celltype}___indel_A.{ext}",
            celltype=[ 'neuron', 'oligo' ], ext=[ 'pdf', 'csv' ]),
        "fig3/panel_c_indel_A.pdf",
        "fig3/panel_c_indel_A.csv",

rule fig4:
    input:
        "fig4/panel_a_umap_plot.pdf",
        "fig4/panel_c_umap_plot.pdf",
        "fig4/panels_cdefg_enrichment_analyses.pdf",
        "fig4/panels_cdefg_enrichment_analyses_half1.pdf",
        "fig4/panels_cdefg_enrichment_analyses_half2.pdf",
        "fig4/panels_cdefg_enrichment_analyses_mda_elderly.pdf",
        "fig4/panel_h_chromhmm.pdf",
        "fig4/panel_h_chromhmm.csv",
        "fig4/panel_h_chromhmm_mda_elderly.pdf",
        "fig4/panel_h_chromhmm_mda_elderly.csv",
        "fig4/panel_i_nott_enhprom.pdf",
        "fig4/panel_i_nott_enhprom.csv",
        "fig4/panel_i_nott_enhprom_mda_elderly.pdf",
        "fig4/panel_i_nott_enhprom_mda_elderly.csv",
        #"fig4/suppl_nott_enhprom.pdf",
        #"fig4/suppl_nott_enhprom.csv",
        #"fig4/suppl_boca2_peaks.pdf",
        #"fig4/suppl_boca2_peaks.csv",
        #"fig4/suppl_dna_repair_hotspots.pdf",
        #"fig4/suppl_dna_repair_hotspots.csv",
        #"fig4/suppl_hic_tads.pdf",
        #"fig4/suppl_hic_tads.csv",

rule suppfig3:
    input:
        "suppfig3/panel_a_gtex_expression_neuron___AB.pdf",
        "suppfig3/panel_a_gtex_expression_neuron___AB.csv",
        "suppfig3/panel_a_gtex_expression_oligo___AB.pdf",
        "suppfig3/panel_a_gtex_expression_oligo___AB.csv",
        "suppfig3/panel_a_gtex_expression_neuron___indel_AB.pdf",
        "suppfig3/panel_a_gtex_expression_neuron___indel_AB.csv",
        "suppfig3/panel_a_gtex_expression_oligo___indel_AB.pdf",
        "suppfig3/panel_a_gtex_expression_oligo___indel_AB.csv",
        "suppfig3/panel_b_repliseq___AB.pdf",
        "suppfig3/panel_b_repliseq___AB.csv",
        "suppfig3/panel_b_repliseq___indel_AB.pdf",
        "suppfig3/panel_b_repliseq___indel_AB.csv",
        "suppfig3/panel_c_chromhmm_tss.pdf",
        "suppfig3/panel_c_chromhmm_tss.csv",

rule fig5:
    input:
        "fig5/all_panels_enrichment_analyses.pdf"

rule fig6:
    input:
        "fig6/panel_a.pdf",
        "fig6/panel_a.csv",
        "fig6/panel_a_mda_gfap_elderly_supp.pdf",
        "fig6/panel_a_mda_gfap_elderly_supp.csv",
        "fig6/panel_a_mda_sox10_elderly_supp.pdf",
        "fig6/panel_a_mda_sox10_elderly_supp.csv",
        "fig6/panel_b_barplot.pdf",
        "fig6/panel_b_heatmap.pdf",
        "fig6/panel_b.csv",
        "fig6/panel_c_barplot.pdf",
        "fig6/panel_c_heatmap.pdf",
        "fig6/panel_c.csv",
        "fig6/panel_d.pdf",
        "fig6/panel_d.csv",
        "fig6/panel_d_mdapta.pdf",
        "fig6/panel_d_mdapta.csv"

rule suppfig5:
    input:
        "suppfig5/cancer_gene_ors.pdf",
        "suppfig5/cancer_gene_ors_full.pdf",
        "suppfig5/cancer_gene_ors_mdapta.pdf",
        "suppfig5/cancer_gene_ors_mdapta_full.pdf"


# This must be defined below all other rules to use the rules.XXX.output directive.
rule all:
    input:
        "supptables/SuppTable1.csv",
        "supptables/SuppTable2.csv",
        rules.fig1.input,
        rules.fig2.input,
        rules.fig3.input,
        rules.fig4.input,
        rules.fig5.input,
        rules.fig6.input,
        rules.suppfig2.input,
        rules.suppfig3.input,
        rules.suppfig5.input,
    default_target: True
'''
